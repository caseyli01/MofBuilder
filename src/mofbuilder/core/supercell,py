import sys
from pathlib import Path

import numpy as np
import networkx as nx
import mpi4py.MPI as MPI
import h5py
import re

try:
    from scipy.optimize import minimize
except ImportError:
    pass

from veloxchem.outputstream import OutputStream
from veloxchem.veloxchemlib import mpi_master
from veloxchem.errorhandler import assert_msg_critical
from veloxchem.molecule import Molecule

from ..io.basic import nn, nl,pname,is_list_A_in_B
from ..utils.geometry import (
    unit_cell_to_cartesian_matrix, fractional_to_cartesian, cartesian_to_fractional,
    locate_min_idx, reorthogonalize_matrix, find_optimal_pairings, find_edge_pairings
)
from .superimpose import superimpose_rotation_only

class SupercellBuilder:

    """
    make supercell of the MOF structure based on the primitive cell graph sG
    use edge to connect the nodes, and link the XOO atoms to the edges
        for multitopic linker MOF, need to bundle the multiedge between two nodes first
        for ditopic linker MOF, no need to bundle the multiedge
        then make the supercell of the primitive cell graph sG
        then make the eG from the supercell superG, which only contains the EDGE and V nodes
        then link the XOO atoms to the EDGE in the eG
    #in following class Defects Builder
    #following also has termination of the unsaturated nodes
    #then write file with IO module

    """
    def __init__(self, comm=None, ostream=None):
        self.comm = comm or MPI.COMM_WORLD
        self.rank = self.comm.Get_rank()
        self.nodes = self.comm.Get_size()
        self.ostream = ostream or OutputStream(sys.stdout if self.rank == mpi_master() else None)

        #need to be set before use
        self.sG = None

        #will be generated during the process
        self.multiedge_bundlings = None
        self.superG = None
        self.eG = None
        self.sc_unit_cell = None
        self.sc_unit_cell_inv = None
        self.supercell = [1, 1, 1]
        self.add_virtual_edge = False
        self.vir_edge_range = 0.5
        self.vir_edge_max_neighbor = 2


    def make_supercell_multitopic(self):
        """
        make the supercell of the multitopic linker MOF
        """
        sG = self.sG
        self.multiedge_bundlings = bundle_multiedge(sG)
        # self.dv_v_pairs, sG = replace_DV_with_corresponding_V(sG) #debug
        superG = update_supercell_node_fpoints_loose(sG, self.supercell)
        superG = update_supercell_edge_fpoints(sG, superG, self.supercell)
        # self.prim_multiedge_bundlings = replace_bundle_dvnode_with_vnode(  #debug
        #    self.dv_v_pairs, self.multiedge_bundlings
        # )
        self.prim_multiedge_bundlings = self.multiedge_bundlings
        self.super_multiedge_bundlings = make_super_multiedge_bundlings(
            self.prim_multiedge_bundlings, self.supercell)
        superG = update_supercell_bundle(superG, self.super_multiedge_bundlings)
        superG = check_multiedge_bundlings_insuperG(
            self.super_multiedge_bundlings, superG)
        self.superG = superG
        return superG

    def make_supercell_ditopic(self):
        """
        make the supercell of the ditopic linker MOF
        """

        sG = self.sG
        # self.dv_v_pairs, sG = replace_DV_with_corresponding_V(sG)
        superG = update_supercell_node_fpoints_loose(sG, self.supercell)
        superG = update_supercell_edge_fpoints(sG, superG, self.supercell)
        self.superG = superG
        return superG

    def set_virtual_edge(self, bool_x=False, range=0.5, max_neighbor=2):
        """
        set the virtual edge addition for the bridge type nodes,
        range is the range to search the virtual edge between two Vnodes directly, should <= 0.5,
        max_neighbor is the maximum number of neighbors of the node with virtual edge
        """

        self.add_virtual_edge = bool(bool_x)
        self.vir_edge_range = range
        self.vir_edge_max_neighbor = max_neighbor

    def add_virtual_edge_for_bridge_node(self, superG):
        """
        after setting the virtual edge search, add the virtual edge to the target supercell superG MOF
        """
        if self.add_virtual_edge:
            add_superG = add_virtual_edge(
                self.sc_unit_cell,
                superG,
                self.vir_edge_range,
                self.vir_edge_max_neighbor,
            )
            print("add virtual edge")
            return add_superG
        else:
            return superG



    def make_eG_from_supereG_multitopic(self):
        """
        make the target MOF cell graph with only EDGE and V, link the XOO atoms to the EDGE
        always need to execute with make_supercell_multitopic
        """

        eG, _ = superG_to_eG_multitopic(self.superG, self.sc_unit_cell)
        self.eG = eG
        return eG

    def add_xoo_to_edge_multitopic(self):
        eG = self.eG
        eG, unsaturated_linker, matched_vnode_xind, xoo_dict = addxoo2edge_multitopic(
            eG, self.sc_unit_cell)
        self.unsaturated_linker = unsaturated_linker
        self.matched_vnode_xind = matched_vnode_xind
        self.xoo_dict = xoo_dict
        self.eG = eG
        return eG

    def make_eG_from_supereG_ditopic(self):
        """
        make the target MOF cell graph with only EDGE and V, link the XOO atoms to the EDGE
        always execute with make_supercell_ditopic
        """

        eG, _ = superG_to_eG_ditopic(self.superG)
        self.eG = eG
        return eG

    def add_xoo_to_edge_ditopic(self):
        """
        analyze eG and link the XOO atoms to the EDGE, update eG, for ditopic linker MOF
        """
        eG = self.eG
        eG, unsaturated_linker, matched_vnode_xind, xoo_dict = addxoo2edge_ditopic(
            eG, self.sc_unit_cell)
        self.unsaturated_linker = unsaturated_linker
        self.matched_vnode_xind = matched_vnode_xind
        self.xoo_dict = xoo_dict
        self.eG = eG
        return eG

    def main_frag_eG(self):
        """
        only keep the main fragment of the target MOF cell, remove the other fragments, to avoid the disconnected fragments
        """
        eG = self.eG
        self.eG = [eG.subgraph(c).copy() for c in nx.connected_components(eG)
                  ][0]
        print("main fragment of the MOF cell is kept"
             )  # ,len(self.eG.nodes()),'nodes')
        # print('fragment size list:',[len(c) for c in nx.connected_components(eG)]) #debug
        return self.eG

    def make_supercell_range_cleaved_eG(self, buffer_plus=0, buffer_minus=0):
        supercell = self.supercell
        new_eG = self.eG.copy()
        eG = self.eG
        removed_edges = []
        removed_nodes = []
        for n in eG.nodes():
            if pname(n) != "EDGE":
                if check_supercell_box_range(eG.nodes[n]["fcoords"], supercell,
                                             buffer_plus, buffer_minus):
                    pass
                else:
                    new_eG.remove_node(n)
                    removed_nodes.append(n)
            elif pname(n) == "EDGE":
                if (arr_dimension(eG.nodes[n]["fcoords"]) == 2
                   ):  # ditopic linker have two points in the fcoords
                    edge_coords = np.mean(eG.nodes[n]["fcoords"], axis=0)
                elif (
                        arr_dimension(eG.nodes[n]["fcoords"]) == 1
                ):  # multitopic linker have one point in the fcoords from EC
                    edge_coords = eG.nodes[n]["fcoords"]

                if check_supercell_box_range(edge_coords, supercell,
                                             buffer_plus, buffer_minus):
                    pass
                else:
                    new_eG.remove_node(n)
                    removed_edges.append(n)

        matched_vnode_xind = self.matched_vnode_xind
        self.matched_vnode_xind = update_matched_nodes_xind(
            removed_nodes,
            removed_edges,
            matched_vnode_xind,
        )

        self.eG = new_eG
        return new_eG, removed_edges, removed_nodes

    def set_node_topic(self, node_topic):
        """
        manually set the node topic, normally should be the same as the maximum degree of the node in the template
        """
        self.node_topic = node_topic

    def find_unsaturated_node_eG(self):
        """
        use the eG to find the unsaturated nodes, whose degree is less than the node topic
        """
        eG = self.eG
        if hasattr(self, "node_topic"):
            node_topic = self.node_topic
        else:
            node_topic = self.node_max_degree
        unsaturated_node = find_unsaturated_node(eG, node_topic)
        self.unsaturated_node = unsaturated_node
        return unsaturated_node

    def find_unsaturated_linker_eG(eG, linker_topics):
        """
        use the eG to find the unsaturated linkers, whose degree is less than linker topic
        """
        new_unsaturated_linker = find_unsaturated_linker(eG, linker_topics)
        return new_unsaturated_linker

    def set_node_terminamtion(self, term_file):
        """
        pdb file, set the node termination file, which contains the information of the node terminations, should have X of connected atom (normally C),
        Y of two connected O atoms (if in carboxylate group) to assist the placement of the node terminations
        """

        term_data = termpdb(term_file)
        term_info = term_data[:, :-3]
        term_coords = term_data[:, -3:]
        xterm, _ = Xpdb(term_data, "X")
        oterm, _ = Xpdb(term_data, "Y")
        term_xvecs = xterm[:, -3:]
        term_ovecs = oterm[:, -3:]
        term_coords = term_coords.astype("float")
        term_xvecs = term_xvecs.astype("float")
        term_ovecs = term_ovecs.astype("float")

        term_ovecs_c = np.mean(np.asarray(term_ovecs), axis=0)
        term_coords = term_coords - term_ovecs_c
        term_xoovecs = np.vstack((term_xvecs, term_ovecs))
        term_xoovecs = term_xoovecs - term_ovecs_c
        self.node_termination = term_file
        self.term_info = term_info
        self.term_coords = term_coords
        self.term_xoovecs = term_xoovecs

    # Function to add node terminations
    def add_terminations_to_unsaturated_node(self):
        """
        use the node terminations to add terminations to the unsaturated nodes

        """
        unsaturated_node = [
            n for n in self.unsaturated_node if n in self.eG.nodes()
        ]
        xoo_dict = self.xoo_dict
        matched_vnode_xind = self.matched_vnode_xind
        eG = self.eG
        sc_unit_cell = self.sc_unit_cell
        (
            unsaturated_vnode_xind_dict,
            unsaturated_vnode_xoo_dict,
            self.matched_vnode_xind_dict,
        ) = make_unsaturated_vnode_xoo_dict(unsaturated_node, xoo_dict,
                                            matched_vnode_xind, eG,
                                            sc_unit_cell)
        # term_file: path to the termination file
        # ex_node_cxo_cc: exposed node coordinates

        node_oovecs_record = []
        for n in eG.nodes():
            eG.nodes[n]["term_c_points"] = {}
        for exvnode_xind_key in unsaturated_vnode_xoo_dict.keys():
            exvnode_x_ccoords = unsaturated_vnode_xoo_dict[exvnode_xind_key][
                "x_cpoints"]
            exvnode_oo_ccoords = unsaturated_vnode_xoo_dict[exvnode_xind_key][
                "oo_cpoints"]
            node_xoo_ccoords = np.vstack(
                [exvnode_x_ccoords, exvnode_oo_ccoords])
            # make the beginning point of the termination to the center of the oo atoms
            node_oo_center_cvec = np.mean(
                exvnode_oo_ccoords[:, 2:5].astype(float),
                axis=0)  # NOTE: modified add the atom type and atom name
            node_xoo_cvecs = (node_xoo_ccoords[:, 2:5].astype(float) -
                              node_oo_center_cvec
                             )  # NOTE: modified add the atom type and atom name
            node_xoo_cvecs = node_xoo_cvecs.astype("float")
            # use record to record the rotation matrix for get rid of the repeat calculation

            indices = [
                index for index, value in enumerate(node_oovecs_record)
                if is_list_A_in_B(node_xoo_cvecs, value[0])
            ]
            if len(indices) == 1:
                rot = node_oovecs_record[indices[0]][1]
            else:
                _, rot, _ = superimpose(self.term_xoovecs, node_xoo_cvecs)
                node_oovecs_record.append((node_xoo_cvecs, rot))
            adjusted_term_vecs = np.dot(self.term_coords,
                                        rot) + node_oo_center_cvec
            adjusted_term = np.hstack((
                np.asarray(self.term_info[:, 0:1]),
                np.asarray(self.term_info[:, 2:3]),
                adjusted_term_vecs,
            ))
            # add the adjusted term to the terms, add index, add the node name
            unsaturated_vnode_xoo_dict[exvnode_xind_key][
                "node_term_c_points"] = (adjusted_term)
            eG.nodes[exvnode_xind_key[0]]["term_c_points"][
                exvnode_xind_key[1]] = (adjusted_term)

        self.unsaturated_vnode_xoo_dict = unsaturated_vnode_xoo_dict
        self.eG = eG
        return eG

    def remove_xoo_from_node(self):
        """
        remove the XOO atoms from the node after adding the terminations, add ['noxoo_f_points'] to the node in eG
        """
        eG = self.eG
        xoo_dict = self.xoo_dict

        all_xoo_indices = []
        for x_ind, oo_ind in xoo_dict.items():
            all_xoo_indices.append(x_ind)
            all_xoo_indices.extend(oo_ind)

        for n in eG.nodes():
            if pname(n) != "EDGE":
                all_f_points = eG.nodes[n]["f_points"]
                noxoo_f_points = np.delete(all_f_points,
                                           all_xoo_indices,
                                           axis=0)
                eG.nodes[n]["noxoo_f_points"] = noxoo_f_points
        self.eG = eG

        return eG

    def get_node_edge_term_grolines(self, eG, sc_unit_cell):
        nodes_eG, edges_eG, terms_eG, node_res_num, edge_res_num, term_res_num = (
            extract_node_edge_term(eG, sc_unit_cell))
        merged_node_edge_term = merge_node_edge_term(nodes_eG, edges_eG,
                                                     terms_eG, node_res_num,
                                                     edge_res_num)
        print("node_res_num: ", node_res_num)
        print("edge_res_num: ", edge_res_num)
        print("term_res_num: ", term_res_num)
        return merged_node_edge_term

    def extract_node_edge_term(self):
        self.nodes_eG, self.edges_eG, self.terms_eG, self.node_res_num, self.edge_res_num, self.term_res_num = (
            extract_node_edge_term(self.eG, self.sc_unit_cell))
        print("node_res_num: ", self.node_res_num)
        print("edge_res_num: ", self.edge_res_num)
        print("term_res_num: ", self.term_res_num)

    def write_node_edge_term_gro(self, gro_name):
        """
        write the node, edge, term to the gro file
        """

        merged_node_edge_term = merge_node_edge_term(self.nodes_eG,
                                                     self.edges_eG,
                                                     self.terms_eG,
                                                     self.node_res_num,
                                                     self.edge_res_num)
        dir_name = "output_gros"
        save_node_edge_term_gro(merged_node_edge_term, gro_name, dir_name)
        print(str(gro_name) + ".gro is saved in folder " + str(dir_name))

        self.merged_node_edge_term = merged_node_edge_term